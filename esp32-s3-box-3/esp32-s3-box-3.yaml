---
substitutions:
  name: esp32-s3-box-3  # 设备名称
  friendly_name: ESP32 S3 Box 3  # 设备友好名称
  # 各种状态下显示的图片文件URL
  loading_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/loading_320_240.png
  idle_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/idle_320_240.png
  listening_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/listening_320_240.png
  thinking_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/thinking_320_240.png
  replying_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/replying_320_240.png
  error_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/error_320_240.png
  timer_finished_illustration_file: https://github.com/esphome/wake-word-voice-assistants/raw/main/casita/timer_finished_320_240.png

  # 各种状态下的背景颜色
  loading_illustration_background_color: "000000"
  idle_illustration_background_color: "000000"
  listening_illustration_background_color: "FFFFFF"
  thinking_illustration_background_color: "FFFFFF"
  replying_illustration_background_color: "FFFFFF"
  error_illustration_background_color: "000000"

  # 语音助手各阶段ID定义
  voice_assist_idle_phase_id: "1"
  voice_assist_listening_phase_id: "2"
  voice_assist_thinking_phase_id: "3"
  voice_assist_replying_phase_id: "4"
  voice_assist_not_ready_phase_id: "10"
  voice_assist_error_phase_id: "11"
  voice_assist_muted_phase_id: "12"
  voice_assist_timer_finished_phase_id: "20"

  # 允许显示的字符集（包含多种语言字符和符号）
  allowed_characters: |-
    一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗·！@#￥%…&*（）—+-=、|【{}】；：‘“”，《。》/？℃℉￡ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~`!$^()_[]\;:'",<.>?
  
  # 添加对非Unicode字符的支持，使用更好的字形集
  font_glyphsets: "GF_Chinese_Simplified"
  # 希腊语使用"Noto Sans"，其他语言使用兼容的字体家族
  font_family: "Noto Sans SC"

esphome:
  name: ${name}  # 设备名称
  friendly_name: ${friendly_name}  # 设备友好名称
  min_version: 2025.5.0  # 最低支持的ESPHome版本
  name_add_mac_suffix: true  # 名称添加MAC后缀
  on_boot:  # 启动时执行的操作
    priority: 600  # 优先级
    then:  # 执行步骤
      - script.execute: draw_display  # 执行绘制显示脚本
      - delay: 30s  # 延迟30秒
      - if:  # 条件判断
          condition:  # 条件
            lambda: return id(init_in_progress);
          then:  # 满足条件执行
            - lambda: id(init_in_progress) = false;
            - script.execute: draw_display  # 执行绘制显示脚本

esp32:
  board: esp32s3box  # 开发板型号
  flash_size: 16MB  # Flash大小
  cpu_frequency: 240MHz  # CPU频率
  framework:  # 框架配置
    type: esp-idf  # 框架类型
    sdkconfig_options:  # SDK配置选项
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"  # 默认CPU频率240MHz
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"  # 数据缓存64KB
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"  # 数据缓存行64B

psram:  # PSRAM配置
  mode: octal  # 模式为八进制
  speed: 80MHz  # 速度80MHz

api:  # API配置
  on_client_connected:  # 客户端连接时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_client_disconnected:  # 客户端断开连接时
    - script.execute: draw_display  # 执行绘制显示脚本

ota:  # OTA配置
  - platform: esphome  # 平台
    id: ota_esphome  # ID

logger:  # 日志配置
  hardware_uart: USB_SERIAL_JTAG  # 硬件UART

wifi:  # WiFi配置
  ap:  # 接入点配置
  on_connect:  # 连接时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_disconnect:  # 断开连接时
    - script.execute: draw_display  # 执行绘制显示脚本

captive_portal:  #  captive portal配置

button:  # 按钮配置
  - platform: factory_reset  # 工厂重置按钮
    id: factory_reset_btn  # ID
    internal: true  # 内部使用

binary_sensor:  # 二进制传感器配置
  - platform: gpio  # GPIO平台
    pin:  # 引脚配置
      number: GPIO0  # 引脚号
      mode: INPUT_PULLUP  # 输入上拉模式
      inverted: true  # 反转
    id: left_top_button  # ID
    internal: true  # 内部使用
    on_multi_click:  # 多点击事件
      - timing:  # 时序
          - ON for at least 50ms  # 至少开50ms
          - OFF for at least 50ms  # 至少关50ms
        then:  # 执行
          - switch.turn_off: timer_ringing  # 关闭定时器铃声
      - timing:  # 时序
          - ON for at least 10s  # 至少开10秒
        then:  # 执行
          - button.press: factory_reset_btn  # 按下工厂重置按钮

output:  # 输出配置
  - platform: ledc  # LEDC平台
    pin: GPIO47  # 引脚
    id: backlight_output  # ID

light:  # 灯光配置
  - platform: monochromatic  # 单色
    id: led  # ID
    name: Screen  # 名称
    icon: "mdi:television"  # 图标
    entity_category: config  # 实体类别
    output: backlight_output  # 输出
    restore_mode: RESTORE_DEFAULT_ON  # 恢复模式
    default_transition_length: 250ms  # 默认过渡时间

i2c:  # I2C配置
  scl: GPIO18  # SCL引脚
  sda: GPIO8  # SDA引脚

i2s_audio:  # I2S音频配置
  - id: i2s_audio_bus  # ID
    i2s_lrclk_pin: GPIO45  # LRCLK引脚
    i2s_bclk_pin: GPIO17  # BCLK引脚
    i2s_mclk_pin: GPIO2  # MCLK引脚

audio_adc:  # 音频ADC配置
  - platform: es7210  # 芯片型号
    id: es7210_adc  # ID
    bits_per_sample: 16bit  # 采样位数
    sample_rate: 16000  # 采样率

audio_dac:  # 音频DAC配置
  - platform: es8311  # 芯片型号
    id: es8311_dac  # ID
    bits_per_sample: 16bit  # 采样位数
    sample_rate: 48000  # 采样率

microphone:  # 麦克风配置
  - platform: i2s_audio  # I2S音频平台
    id: box_mic  # ID
    sample_rate: 16000  # 采样率
    i2s_din_pin: GPIO16  # DIN引脚
    bits_per_sample: 16bit  # 采样位数
    adc_type: external  # ADC类型

speaker:  # 扬声器配置
  - platform: i2s_audio  # I2S音频平台
    id: box_speaker  # ID
    i2s_dout_pin: GPIO15  # DOUT引脚
    dac_type: external  # DAC类型
    sample_rate: 48000  # 采样率
    bits_per_sample: 16bit  # 采样位数
    channel: left  # 声道
    audio_dac: es8311_dac  # 音频DAC
    buffer_duration: 100ms  # 缓冲时长

media_player:  # 媒体播放器配置
  - platform: speaker  # 扬声器平台
    name: None  # 名称
    id: speaker_media_player  # ID
    volume_min: 0.5  # 最小音量
    volume_max: 0.8  # 最大音量
    announcement_pipeline:  # 公告流水线
      speaker: box_speaker  # 扬声器
      format: FLAC  # 格式
      sample_rate: 48000  # 采样率
      num_channels: 1  # 声道数（S3 Box只有一个输出声道）
    files:  # 文件
      - id: timer_finished_sound  # ID
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac  # 文件URL
    on_announcement:  # 公告时
      # 如果麦克风正在捕获，停止唤醒词（mWW或VA）
      - if:  # 条件判断
          condition:  # 条件
            - microphone.is_capturing:  # 麦克风是否在捕获
          then:  # 满足条件执行
            - script.execute: stop_wake_word  # 执行停止唤醒词脚本
            # 确保VA在继续之前停止
            - if:  # 条件判断
                condition:  # 条件
                  - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
                then:  # 满足条件执行
                  - wait_until:  # 等待直到
                      - not:  # 非
                          voice_assistant.is_running:  # 语音助手是否在运行
      # 由于VA没有运行，这是用户发起的媒体播放。绘制静音显示
      - if:  # 条件判断
          condition:  # 条件
            not:  # 非
              voice_assistant.is_running:  # 语音助手是否在运行
          then:  # 满足条件执行
            - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
            - script.execute: draw_display  # 执行绘制显示脚本
    on_idle:  # 空闲时
      # 由于VA没有运行，这是用户发起的媒体播放结束。重新启动唤醒词。
      - if:  # 条件判断
          condition:  # 条件
            not:  # 非
              voice_assistant.is_running:  # 语音助手是否在运行
          then:  # 满足条件执行
            - script.execute: start_wake_word  # 执行启动唤醒词脚本
            - script.execute: set_idle_or_mute_phase  # 执行设置空闲或静音阶段脚本
            - script.execute: draw_display  # 执行绘制显示脚本

micro_wake_word:  # 微型唤醒词配置
  id: mww  # ID
  models:  # 模型
    - okay_nabu  # 模型名称
  on_wake_word_detected:  # 检测到唤醒词时
    - voice_assistant.start:  # 启动语音助手
        wake_word: !lambda return wake_word;

voice_assistant:  # 语音助手配置
  id: va  # ID
  microphone: box_mic  # 麦克风
  media_player: speaker_media_player  # 媒体播放器
  micro_wake_word: mww  # 微型唤醒词
  noise_suppression_level: 2  # 噪声抑制级别
  auto_gain: 31dBFS  # 自动增益
  volume_multiplier: 2.0  # 音量倍数
  on_listening:  # 监听时
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_request  # ID
        state: "..."  # 状态
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_response  # ID
        state: "..."  # 状态
    - script.execute: draw_display  # 执行绘制显示脚本
  on_stt_vad_end:  # STT VAD结束时
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: draw_display  # 执行绘制显示脚本
  on_stt_end:  # STT结束时
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_request  # ID
        state: !lambda return x;
    - script.execute: draw_display  # 执行绘制显示脚本
  on_tts_start:  # TTS开始时
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_response  # ID
        state: !lambda return x;
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    - script.execute: draw_display  # 执行绘制显示脚本
  on_end:  # 结束时
    # 等待一小段时间，看看是否有公告开始
    - wait_until:  # 等待直到
        condition:  # 条件
          - media_player.is_announcing:  # 媒体播放器是否在公告
        timeout: 0.5s  # 超时时间
    # 公告结束，I2S总线空闲
    - wait_until:  # 等待直到
        - and:  # 与
            - not:  # 非
                media_player.is_announcing:  # 媒体播放器是否在公告
            - not:  # 非
                speaker.is_playing:  # 扬声器是否在播放
    # 如果启用，只重启mWW；流式唤醒词会自动重启
    - if:  # 条件判断
        condition:  # 条件
          - lambda: return id(wake_word_engine_location).state == "On device";
        then:  # 满足条件执行
          - lambda: id(va).set_use_wake_word(false);
          - micro_wake_word.start:  # 启动微型唤醒词
    - script.execute: set_idle_or_mute_phase  # 执行设置空闲或静音阶段脚本
    - script.execute: draw_display  # 执行绘制显示脚本
    # 清除文本传感器
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_request  # ID
        state: ""  # 状态
    - text_sensor.template.publish:  # 发布文本传感器状态
        id: text_response  # ID
        state: ""  # 状态
  on_error:  # 错误时
    - if:  # 条件判断
        condition:  # 条件
          lambda: return !id(init_in_progress);
        then:  # 满足条件执行
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: draw_display  # 执行绘制显示脚本
          - delay: 1s  # 延迟1秒
          - if:  # 条件判断
              condition:  # 条件
                switch.is_off: mute  # 静音开关是否关闭
              then:  # 满足条件执行
                - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
              else:  # 不满足条件执行
                - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
          - script.execute: draw_display  # 执行绘制显示脚本
  on_client_connected:  # 客户端连接时
    - lambda: id(init_in_progress) = false;
    - script.execute: start_wake_word  # 执行启动唤醒词脚本
    - script.execute: set_idle_or_mute_phase  # 执行设置空闲或静音阶段脚本
    - script.execute: draw_display  # 执行绘制显示脚本
  on_client_disconnected:  # 客户端断开连接时
    - script.execute: stop_wake_word  # 执行停止唤醒词脚本
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: draw_display  # 执行绘制显示脚本
  on_timer_started:  # 定时器启动时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_timer_cancelled:  # 定时器取消时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_timer_updated:  # 定时器更新时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_timer_tick:  # 定时器计时时
    - script.execute: draw_display  # 执行绘制显示脚本
  on_timer_finished:  # 定时器结束时
    - switch.turn_on: timer_ringing  # 打开定时器铃声
    - wait_until:  # 等待直到
        media_player.is_announcing:  # 媒体播放器是否在公告
    - lambda: id(voice_assistant_phase) = ${voice_assist_timer_finished_phase_id};
    - script.execute: draw_display  # 执行绘制显示脚本

script:
  # 绘制显示脚本
  - id: draw_display
    then:
      - if:
          condition:
            lambda: return !id(init_in_progress);
          then:
            - if:
                condition:
                  wifi.connected:
                then:
                  - if:
                      condition:
                        api.connected:
                      then:
                        - lambda: |
                            switch(id(voice_assistant_phase)) {
                              case ${voice_assist_listening_phase_id}:
                                id(s3_box_lcd).show_page(listening_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_thinking_phase_id}:
                                id(s3_box_lcd).show_page(thinking_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_replying_phase_id}:
                                id(s3_box_lcd).show_page(replying_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_error_phase_id}:
                                id(s3_box_lcd).show_page(error_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_muted_phase_id}:
                                id(s3_box_lcd).show_page(muted_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_not_ready_phase_id}:
                                id(s3_box_lcd).show_page(no_ha_page);
                                id(s3_box_lcd).update();
                                break;
                              case ${voice_assist_timer_finished_phase_id}:
                                id(s3_box_lcd).show_page(timer_finished_page);
                                id(s3_box_lcd).update();
                                break;
                              default:
                                id(s3_box_lcd).show_page(idle_page);
                                id(s3_box_lcd).update();
                            }
                      else:
                        - display.page.show: no_ha_page
                        - component.update: s3_box_lcd
                else:
                  - display.page.show: no_wifi_page
                  - component.update: s3_box_lcd
          else:
            - display.page.show: initializing_page
            - component.update: s3_box_lcd

  # 获取第一个活跃定时器脚本
  - id: fetch_first_active_timer
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(global_first_active_timer) = output_timer;
  
  # 检查是否有活跃定时器脚本
  - id: check_if_timers_active
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if(iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(global_is_timer_active) = output;
  
  # 获取第一个定时器脚本
  - id: fetch_first_timer
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(global_first_timer) = output_timer;
  
  # 检查是否有定时器脚本
  - id: check_if_timers
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            output = true;
          }
          id(global_is_timer) = output;

  # 绘制定时器时间线脚本
  - id: draw_timer_timeline
    then:
      - lambda: |
          id(check_if_timers_active).execute();
          id(check_if_timers).execute();
          if (id(global_is_timer_active)){
            id(fetch_first_active_timer).execute();
            int active_pixels = round( 320 * id(global_first_active_timer).seconds_left / max(id(global_first_active_timer).total_seconds , static_cast<uint32_t>(1)) );
            if (active_pixels > 0){
              id(s3_box_lcd).filled_rectangle(0 , 225 , 320 , 15 , Color::WHITE );
              id(s3_box_lcd).filled_rectangle(0 , 226 , active_pixels , 13 , id(active_timer_color) );
            }
          } else if (id(global_is_timer)){
            id(fetch_first_timer).execute();
            int active_pixels = round( 320 * id(global_first_timer).seconds_left / max(id(global_first_timer).total_seconds , static_cast<uint32_t>(1)));
            if (active_pixels > 0){
              id(s3_box_lcd).filled_rectangle(0 , 225 , 320 , 15 , Color::WHITE );
              id(s3_box_lcd).filled_rectangle(0 , 226 , active_pixels , 13 , id(paused_timer_color) );
            }
          }
  # 绘制活跃定时器部件脚本
  - id: draw_active_timer_widget
    then:
      - lambda: |
          id(check_if_timers_active).execute();
          if (id(global_is_timer_active)){
            id(s3_box_lcd).filled_rectangle(80 , 40 , 160 , 50 , Color::WHITE );
            id(s3_box_lcd).rectangle(80 , 40 , 160 , 50 , Color::BLACK );

            id(fetch_first_active_timer).execute();
            int hours_left = floor(id(global_first_active_timer).seconds_left / 3600);
            int minutes_left = floor((id(global_first_active_timer).seconds_left - hours_left * 3600) / 60);
            int seconds_left = id(global_first_active_timer).seconds_left - hours_left * 3600 - minutes_left * 60 ;
            auto display_hours = (hours_left < 10 ? "0" : "") + std::to_string(hours_left);
            auto display_minute = (minutes_left < 10 ? "0" : "") + std::to_string(minutes_left);
            auto display_seconds = (seconds_left  < 10 ? "0" : "") + std::to_string(seconds_left) ;

            std::string display_string = "";
            if (hours_left > 0) {
              display_string = display_hours + ":" + display_minute;
            } else {
              display_string = display_minute + ":" + display_seconds;
            }
            id(s3_box_lcd).printf(120, 47, id(font_timer), Color::BLACK, "%s", display_string.c_str());
          }
  # 根据配置的位置启动mWW或流式唤醒词
  - id: start_wake_word
    then:
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - micro_wake_word.start:
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous:
  # 根据配置的位置停止mWW或流式唤醒词
  - id: stop_wake_word
    then:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - micro_wake_word.stop:
  # 根据软件静音开关的状态，将语音助手阶段设置为空闲或静音
  - id: set_idle_or_mute_phase
    then:
      - if:
          condition:
            switch.is_off: mute
          then:
            - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          else:
            - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};

switch:  # 开关配置
  - platform: gpio  # GPIO平台
    name: Speaker Enable  # 名称
    pin: GPIO46  # 引脚
    restore_mode: RESTORE_DEFAULT_ON  # 恢复模式
    entity_category: config  # 实体类别
    disabled_by_default: true  # 默认禁用
  - platform: template  # 模板平台
    name: Mute  # 名称
    id: mute  # ID
    icon: "mdi:microphone-off"  # 图标
    optimistic: true  # 乐观模式
    restore_mode: RESTORE_DEFAULT_OFF  # 恢复模式
    entity_category: config  # 实体类别
    on_turn_off:  # 关闭时
      - microphone.unmute:  # 取消麦克风静音
      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
      - script.execute: draw_display  # 执行绘制显示脚本
    on_turn_on:  # 打开时
      - microphone.mute:  # 麦克风静音
      - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
      - script.execute: draw_display  # 执行绘制显示脚本
  - platform: template  # 模板平台
    id: timer_ringing  # ID
    optimistic: true  # 乐观模式
    internal: true  # 内部使用
    restore_mode: ALWAYS_OFF  # 恢复模式
    on_turn_off:  # 关闭时
      # 关闭重复模式并禁用播放列表项目之间的暂停
      - lambda: |-
              id(speaker_media_player)
                ->make_call()
                .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
                .set_announcement(true)
                .perform();
              id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);
      # 停止播放警报
      - media_player.stop:  # 停止媒体播放器
          announcement: true  # 公告
    on_turn_on:  # 打开时
      # 打开重复模式，播放列表项目/重复之间暂停1000毫秒
      - lambda: |-
            id(speaker_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 1000);
      - media_player.speaker.play_on_device_media_file:  # 播放设备上的媒体文件
          media_file: timer_finished_sound  # 媒体文件
          announcement: true  # 公告
      - delay: 15min  # 延迟15分钟
      - switch.turn_off: timer_ringing  # 关闭定时器铃声

select:  # 选择器配置
  - platform: template  # 模板平台
    entity_category: config  # 实体类别
    name: Wake word engine location  # 名称
    id: wake_word_engine_location  # ID
    icon: "mdi:account-voice"  # 图标
    optimistic: true  # 乐观模式
    restore_value: true  # 恢复值
    options:  # 选项
      - In Home Assistant  # 在Home Assistant中
      - On device  # 在设备上
    initial_option: On device  # 初始选项
    on_value:  # 值变化时
      - if:  # 条件判断
          condition:  # 条件
            lambda: return !id(init_in_progress);
          then:  # 满足条件执行
            - wait_until:  # 等待直到
                lambda: return id(voice_assistant_phase) == ${voice_assist_muted_phase_id} || id(voice_assistant_phase) == ${voice_assist_idle_phase_id};
            - if:  # 条件判断
                condition:  # 条件
                  lambda: return x == "In Home Assistant";
                then:  # 满足条件执行
                  - micro_wake_word.stop  # 停止微型唤醒词
                  - delay: 500ms  # 延迟500毫秒
                  - if:  # 条件判断
                      condition:  # 条件
                        switch.is_off: mute  # 静音开关是否关闭
                      then:  # 满足条件执行
                        - lambda: id(va).set_use_wake_word(true);
                        - voice_assistant.start_continuous:  # 启动语音助手连续模式
            - if:  # 条件判断
                condition:  # 条件
                  lambda: return x == "On device";
                then:  # 满足条件执行
                  - lambda: id(va).set_use_wake_word(false);
                  - voice_assistant.stop  # 停止语音助手
                  - delay: 500ms  # 延迟500毫秒
                  - if:  # 条件判断
                      condition:  # 条件
                        switch.is_off: mute  # 静音开关是否关闭
                      then:  # 满足条件执行
                        - micro_wake_word.start  # 启动微型唤醒词

globals:  # 全局变量配置
  - id: init_in_progress  # ID
    type: bool  # 类型
    restore_value: false  # 不恢复值
    initial_value: "true"  # 初始值
  - id: voice_assistant_phase  # ID
    type: int  # 类型
    restore_value: false  # 不恢复值
    initial_value: ${voice_assist_not_ready_phase_id}  # 初始值
  - id: global_first_active_timer  # ID
    type: voice_assistant::Timer  # 类型
    restore_value: false  # 不恢复值
  - id: global_is_timer_active  # ID
    type: bool  # 类型
    restore_value: false  # 不恢复值
  - id: global_first_timer  # ID
    type: voice_assistant::Timer  # 类型
    restore_value: false  # 不恢复值
  - id: global_is_timer  # ID
    type: bool  # 类型
    restore_value: false  # 不恢复值

image:  # 图像配置
  - file: ${error_illustration_file}  # 文件
    id: casita_error  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${idle_illustration_file}  # 文件
    id: casita_idle  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${listening_illustration_file}  # 文件
    id: casita_listening  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${thinking_illustration_file}  # 文件
    id: casita_thinking  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${replying_illustration_file}  # 文件
    id: casita_replying  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${timer_finished_illustration_file}  # 文件
    id: casita_timer_finished  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: ${loading_illustration_file}  # 文件
    id: casita_initializing  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: https://github.com/esphome/wake-word-voice-assistants/raw/main/error_box_illustrations/error-no-wifi.png  # 文件
    id: error_no_wifi  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度
  - file: https://github.com/esphome/wake-word-voice-assistants/raw/main/error_box_illustrations/error-no-ha.png  # 文件
    id: error_no_ha  # ID
    resize: 320x240  # 尺寸
    type: RGB  # 类型
    transparency: alpha_channel  # 透明度

# 3. 重新配置字体（替换原有font段）
font:  # 字体配置
  - file:  # 文件
      type: gfonts  # 类型
      family: "Noto Sans SC"  # 字体家族
      weight: 400  # 字重
      italic: false  # 不斜体
    id: font_request  # ID
    size: 15  # 大小
    glyphs: ${allowed_characters}  # 字形
    ignore_missing_glyphs: true  # 忽略缺失的字形

  - file:  # 文件
      type: gfonts  # 类型
      family: "Noto Sans SC"  # 字体家族
      weight: 400  # 字重
      italic: false  # 不斜体
    id: font_response  # ID
    size: 15  # 大小
    glyphs: ${allowed_characters}  # 字形
    ignore_missing_glyphs: true  # 忽略缺失的字形

  - file:  # 文件
      type: gfonts  # 类型
      family: "Noto Sans SC"  # 字体家族
      weight: 400  # 字重
      italic: false  # 不斜体
    id: font_timer  # ID
    size: 30  # 大小
    glyphs: ${allowed_characters}  # 字形
    ignore_missing_glyphs: true  # 忽略缺失的字形

text_sensor:  # 文本传感器配置
  - id: text_request  # ID
    platform: template  # 模板平台
    on_value:  # 值变化时
      lambda: |-
        if(id(text_request).state.length()>32) {
          std::string name = id(text_request).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_request).state = (truncated+"...").c_str();
        }

  - id: text_response  # ID
    platform: template  # 模板平台
    on_value:  # 值变化时
      lambda: |-
        if(id(text_response).state.length()>32) {
          std::string name = id(text_response).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_response).state = (truncated+"...").c_str();
        }

color:  # 颜色配置
  - id: idle_color  # ID
    hex: ${idle_illustration_background_color}  # 十六进制颜色
  - id: listening_color  # ID
    hex: ${listening_illustration_background_color}  # 十六进制颜色
  - id: thinking_color  # ID
    hex: ${thinking_illustration_background_color}  # 十六进制颜色
  - id: replying_color  # ID
    hex: ${replying_illustration_background_color}  # 十六进制颜色
  - id: loading_color  # ID
    hex: ${loading_illustration_background_color}  # 十六进制颜色
  - id: error_color  # ID
    hex: ${error_illustration_background_color}  # 十六进制颜色
  - id: active_timer_color  # ID
    hex: "26ed3a"  # 十六进制颜色
  - id: paused_timer_color  # ID
    hex: "3b89e3"  # 十六进制颜色

spi:  # SPI配置
  - id: spi_bus  # ID
    clk_pin: 7  # 时钟引脚
    mosi_pin: 6  # MOSI引脚

display:  # 显示配置
  - platform: ili9xxx  # 平台
    id: s3_box_lcd  # ID
    model: S3BOX  # 型号
    invert_colors: false  # 不反转颜色
    data_rate: 40MHz  # 数据速率
    cs_pin: 5  # CS引脚
    dc_pin: 4  # DC引脚
    reset_pin:  # 复位引脚
      number: 48  # 引脚号
      inverted: true  # 反转
    update_interval: never  # 更新间隔
    pages:
      # 空闲页面
      - id: idle_page
        lambda: |-
          it.fill(id(idle_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_idle), ImageAlign::CENTER);
          id(draw_timer_timeline).execute();
          id(draw_active_timer_widget).execute();
      # 监听页面
      - id: listening_page
        lambda: |-
          it.fill(id(listening_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_listening), ImageAlign::CENTER);
          id(draw_timer_timeline).execute();
      # 思考页面
      - id: thinking_page
        lambda: |-
          it.fill(id(thinking_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_thinking), ImageAlign::CENTER);
          it.filled_rectangle(20 , 20 , 280 , 30 , Color::WHITE );
          it.rectangle(20 , 20 , 280 , 30 , Color::BLACK );
          it.printf(30, 25, id(font_request), Color::BLACK, "%s", id(text_request).state.c_str());
          id(draw_timer_timeline).execute();
      # 回复页面
      - id: replying_page
        lambda: |-
          it.fill(id(replying_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_replying), ImageAlign::CENTER);
          it.filled_rectangle(20 , 20 , 280 , 30 , Color::WHITE );
          it.rectangle(20 , 20 , 280 , 30 , Color::BLACK );
          it.filled_rectangle(20 , 190 , 280 , 30 , Color::WHITE );
          it.rectangle(20 , 190 , 280 , 30 , Color::BLACK );
          it.printf(30, 25, id(font_request), Color::BLACK, "%s", id(text_request).state.c_str());
          it.printf(30, 195, id(font_response), Color::BLACK, "%s", id(text_response).state.c_str());
          id(draw_timer_timeline).execute();
      # 定时器结束页面
      - id: timer_finished_page
        lambda: |-
          it.fill(id(idle_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_timer_finished), ImageAlign::CENTER);
      # 错误页面
      - id: error_page
        lambda: |-
          it.fill(id(error_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_error), ImageAlign::CENTER);
      # 无Home Assistant页面
      - id: no_ha_page
        lambda: |-
          it.image((it.get_width() / 2), (it.get_height() / 2), id(error_no_ha), ImageAlign::CENTER);
      # 无WiFi页面
      - id: no_wifi_page
        lambda: |-
          it.image((it.get_width() / 2), (it.get_height() / 2), id(error_no_wifi), ImageAlign::CENTER);
      # 初始化页面
      - id: initializing_page
        lambda: |-
          it.fill(id(loading_color));
          it.image((it.get_width() / 2), (it.get_height() / 2), id(casita_initializing), ImageAlign::CENTER);
      # 静音页面
      - id: muted_page
        lambda: |-
          it.fill(Color::BLACK);
          id(draw_timer_timeline).execute();
          id(draw_active_timer_widget).execute();